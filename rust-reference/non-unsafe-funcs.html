<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Verifying non-&#x60;unsafe&#x60; functions - The VeriFast for Rust Reference</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The VeriFast for Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="verifying-non-unsafe-functions"><a class="header" href="#verifying-non-unsafe-functions">Verifying non-<code>unsafe</code> functions</a></h1>
<h2 id="rustbelt"><a class="header" href="#rustbelt">RustBelt</a></h2>
<p>A core value proposition of Rust is that well-typed programs have no undefined behavior, under certain conditions on the use of <code>unsafe</code> blocks. The <a href="https://plv.mpi-sws.org/rustbelt/">RustBelt</a> project has developed a mathematically precise proposal for what those conditions are. In this proposal, a <em>semantics</em> is defined for Rust's types and typing judgments in <em>separation logic</em>, providing a definition of whether a function is <em>semantically well-typed</em> that talks only about the function's <em>behavior</em>, not about its precise syntactic structure, and is therefore applicable to functions containing <code>unsafe</code> blocks. They have proven the soundness of Rust's type checker with respect to this semantics, implying that if a function that does not contain <code>unsafe</code> blocks is syntactically well-typed, then it is semantically well-typed. Therefore, if a program consists of modules that use <code>unsafe</code> blocks and client code that does not, it suffices to establish that these modules are semantically well-typed to be able to conclude that the program as a whole is semantically well-typed and therefore has no undefined behavior.<sup class="footnote-reference"><a href="#rustbelt-limitations">1</a></sup></p>
<p>In order to be able to express the semantics of mutable references and shared references, as well as the semantics of many of the uses of <em>interior mutability</em> in the Rust standard library, the RustBelt authors have proposed the <em>lifetime logic</em>, which defines separation logic concepts such as <em>lifetime tokens</em>, <em>full borrows</em>, <em>fractured borrows</em>, <em>thread tokens</em>, and <em>nonatomic borrows</em>.</p>
<p>An excellent resource for learning more about the RustBelt proposal and the advanced separation logic Iris that underlies it is <a href="https://research.ralfj.de/thesis.html">Ralf Jung's thesis</a>.</p>
<div class="footnote-definition" id="rustbelt-limitations"><sup class="footnote-definition-label">1</sup>
<p>More accurately speaking, the RustBelt authors have defined semantic well-typedness for a somewhat simplified version of Rust called lambda-Rust, and have proven soundness of lambda-Rust's type checker, which is a simplified version of that of Rust. Notable aspects not taken into account in the original RustBelt work include destructors (<code>drop</code>), unwinding, and Rust's aliasing rules.</p>
</div>
<h2 id="rustbelt-and-the-lifetime-logic-in-verifast"><a class="header" href="#rustbelt-and-the-lifetime-logic-in-verifast">RustBelt and the lifetime logic in VeriFast</a></h2>
<p>An axiomatisation of the lifetime logic into VeriFast's logic and some further RustBelt-related definitions and axioms can be found in the following files:</p>
<ul>
<li><a href="https://github.com/verifast/verifast/blob/master/bin/rust/rust_belt/lifetime_logic.rsspec"><code>bin/rust/rust_belt/lifetime_logic.rsspec</code></a></li>
<li><a href="https://github.com/verifast/verifast/blob/master/bin/rust/rust_belt/general.rsspec"><code>bin/rust/rust_belt/general.rsspec</code></a></li>
</ul>
<h2 id="semantic-well-typedness-of-functions-in-verifast"><a class="header" href="#semantic-well-typedness-of-functions-in-verifast">Semantic well-typedness of functions in VeriFast</a></h2>
<p>If a crate under verification defines a function not marked as <code>unsafe</code>, VeriFast generates a specification for that function that expresses the function's semantic well-typedness. If the function is annotated with an explicit specification as well, VeriFast first verifies that the explicit specification implies the generated one, and then verifies the function body against the explicit specification; otherwise, VeriFast verifies the function body against the generated specification.</p>
<p>For a function <code>fn f&lt;'a, 'b : 'a, T, U&gt;(x1: T1, ..., xN: TN) -&gt; U</code>, the generated specification is as follows:</p>
<pre><code>req thread_token(?_t) &amp;*&amp;
    [?_q_a]lifetime_token('a) &amp;*&amp;
    [?_q_b]lifetime_token('b) &amp;*&amp; 
    lifetime_inclusion('a, 'b) == true &amp;*&amp;
    &lt;T1&gt;.own(_t, x1) &amp;*&amp;
    ...
    &lt;TN&gt;.own(_t, xN);
ens thread_token(_t) &amp;*&amp;
    [_q_a]lifetime_token('a) &amp;*&amp;
    [_q_b]lifetime_token('b) &amp;*&amp;
    &lt;U&gt;.own(_t, result);
</code></pre>
<h3 id="drop-functions"><a class="header" href="#drop-functions">Drop functions</a></h3>
<p>If the crate under verification implements Drop for a struct <code>S&lt;'a&gt;</code> with fields <code>f1 : T1</code> through <code>fN : TN</code>, VeriFast generates the following specification for <code>drop(&amp;mut self)</code>:</p>
<pre><code>req thread_token(?_t) &amp;*&amp;
    [?_q_a]lifetime_token('a) &amp;*&amp;
    &lt;S&gt;.full_borrow_content(_t, self);
ens thread_token(_t) &amp;*&amp;
    [_q_a]lifetime_token('a) &amp;*&amp;
    &lt;T1&gt;.full_borrow_content(_t, &amp;(*self).f1) &amp;*&amp;
    ...
    &lt;TN&gt;.full_borrow_content(_t, &amp;(*self).fN);
</code></pre>
<h2 id="semantics-of-types-in-verifast"><a class="header" href="#semantics-of-types-in-verifast">Semantics of types in VeriFast</a></h2>
<p>For simple types T such as <code>bool</code> and the integer types, we simply have <code>&lt;T&gt;.own(t, x) = true</code>. Here are some more interesting cases:</p>
<ul>
<li><code>&lt;&amp;'a mut T&gt;.own(t, l) = full_borrow('a, &lt;T&gt;.full_borrow_content(t, l))</code></li>
<li><code>&lt;&amp;'a T&gt;.own(t, l) = &lt;T&gt;.share('a, t, l)</code></li>
</ul>
<p>For any type T, we have <code>&lt;T&gt;.full_borrow_content(t, l) = *l |-&gt; ?x &amp;*&amp; &lt;T&gt;.own(t, x)</code>.</p>
<p>For simple types T such as <code>bool</code> and the integer types, we simply have <code>&lt;T&gt;.share(k, t, l) = frac_borrow(k, &lt;T&gt;.full_borrow_content(t, l))</code>.</p>
<p>If the crate under verification defines a struct S, it can define a custom semantics for type S by defining the <code>&lt;S&gt;.own</code> and <code>&lt;S&gt;.share</code> predicates.<sup class="footnote-reference"><a href="#struct_preds">2</a></sup> If it does so, it must also prove a number of <em>proof obligations</em> about these predicates.</p>
<div class="footnote-definition" id="struct_preds"><sup class="footnote-definition-label">2</sup>
<p>Note: as part of processing a type predicate definition <code>pred &lt;S&gt;.p(xs) = A;</code>, VeriFast introduces a predicate definition <code>pred S_p(xs) = A;</code>. Therefore, <code>&lt;S&gt;.own</code> and <code>S_own</code> are equivalent, and so are <code>&lt;S&gt;.share</code> and <code>S_share</code>.</p>
</div>
<h3 id="proof-obligations-for-own"><a class="header" href="#proof-obligations-for-own">Proof obligations for <code>own</code></a></h3>
<p>If a crate defines a struct S as well as a custom definition of <code>&lt;S&gt;.own</code>, and the struct's field types are not trivially droppable and the struct does not implement the Drop trait, then the crate must prove the following lemma:</p>
<pre><code>lem S_drop()
    req S_own(?t, ?s);
    ens &lt;T1&gt;.own(t, s.f1) &amp;*&amp; ... &amp;*&amp; &lt;Tn&gt;.own(t, s.fn);
</code></pre>
<p>where the fields of S are <code>f1</code> through <code>fn</code> and their types are T1 through Tn.</p>
<p>If a crate defines a struct S as well as a custom definition of <code>&lt;S&gt;.own</code>, and S is Send, and the <code>own</code> predicate mentions the thread id, then the crate must prove the following lemma:</p>
<pre><code>lem S_send(t1: thread_id_t)
    req S_own(?t, ?s);
    ens S_own(t1, s);
</code></pre>
<h3 id="proof-obligations-for-share"><a class="header" href="#proof-obligations-for-share">Proof obligations for <code>share</code></a></h3>
<p>If a crate defines a struct S as well as a custom definition of <code>&lt;S&gt;.share</code>, then the crate must prove the following two lemmas:</p>
<pre><code>lem S_share_full(k: lifetime_t, t: thread_id_t, l: *S)
    req atomic_mask(Nlft) &amp;*&amp; [?q]lifetime_token(k) &amp;*&amp; full_borrow(k, S_full_borrow_content(t, l));
    ens atomic_mask(Nlft) &amp;*&amp; [q]lifetime_token(k) &amp;*&amp; [_]S_share(k, t, l);

lem S_share_mono(k: lifetime_t, k1: lifetime_t, t: thread_id_t, l: *S)
    req lifetime_inclusion(k1, k) == true &amp;*&amp; [_]S_share(k, t, l);
    ens [_]S_share(k1, t, l);
</code></pre>
<p>Additionally, if S is Sync and the share predicate mentions the thread id, then the crate must prove the following lemma:</p>
<pre><code>lem S_sync(t1: thread_id_t)
    req [_]S_share(?k, ?t, ?l);
    ens [_]S_share(k, t1, l);
</code></pre>
<h3 id="generic-structs"><a class="header" href="#generic-structs">Generic structs</a></h3>
<p>If struct S is generic in type parameters T1 through Tm, each of the above lemmas must also be generic in the same parameters. Furthermore, they may additionally require and ensure <code>type_interp::&lt;Ti&gt;()</code>, for each <code>i</code>. Furthermore, if a type parameter is Send or Sync, an <code>is_Send(typeid(Ti)) == true</code> or <code>is_Sync(typeid(Ti)) == true</code> conjunct may be added to the precondition. For example:</p>
<pre><code>lem Pair_send&lt;A, B&gt;(t1: thread_id_t)
    req type_interp::&lt;A&gt;() &amp;*&amp; type_interp::&lt;B&gt;() &amp;*&amp; Pair_own::&lt;A, B&gt;(?t, ?pair) &amp;*&amp; is_Send(typeid(A)) &amp;&amp; is_Send(typeid(B));
    ens type_interp::&lt;A&gt;() &amp;*&amp; type_interp::&lt;B&gt;() &amp;*&amp; Pair_own::&lt;A, B&gt;(t1, pair);
{
    open Pair_own::&lt;A, B&gt;(t, pair);
    Send::send::&lt;A&gt;(t, t1, pair.fst);
    Send::send::&lt;B&gt;(t, t1, pair.snd);
    close Pair_own::&lt;A, B&gt;(t1, pair);
}
</code></pre>
<div class="warning">
<blockquote>
<p>Further proof obligations are necessary to ensure soundness with respect to Rust's <a href="https://doc.rust-lang.org/nomicon/subtyping.html">variance</a> rules. VeriFast currently generates an <code>S_own_mono</code> proof obligation but its design has known problems. There are plans for an improved design but this is future work. See <a href="https://github.com/verifast/verifast/issues/610">#610</a>.</p>
</blockquote>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ghost-decls.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ghost-decls.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
